import json
import sys
import os
from collections import defaultdict

def scan_file_for_gaps(file_path, gap_threshold=30):
    """
    Since we have indentified some dips in the graph generated by scan-all-time.py
    We scan the data files that are impacted to see what nodes and realizations are impacted
    Scans a JSONL file for devices that has a gap > 30s.
    """
    
    # Check if file exists
    if not os.path.exists(file_path):
        print(f"Error: The file '{file_path}' was not found.")
        return

    print(f"Scanning file: {file_path}...")
    
    # Dictionary to hold list of timestamps for each unique DevID
    # Structure: { "dev_id_1": [100, 101, 102], "dev_id_2": [...] }
    device_timeline = defaultdict(list)
    
    line_count = 0
    
    # 1. Read File Line by Line
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            for line in f:
                line_count += 1
                line = line.strip()
                if not line: continue # Skip empty lines
                
                try:
                    record = json.loads(line)
                    dev_id = record.get('DevID')
                    timestamp = record.get('TimeStamp')
                    
                    if dev_id is not None and timestamp is not None:
                        device_timeline[dev_id].append(int(timestamp))
                        
                except (json.JSONDecodeError, ValueError):
                    # Optional: Print warning for bad lines
                    # print(f"Warning: skipped malformed JSON on line {line_count}")
                    continue
    except Exception as e:
        print(f"An error occurred while reading the file: {e}")
        return

    problematic_devices = []

    # 2. Analyze Timelines
    # We sort timestamps for every device to ensure we check time sequentially
    for dev_id, timestamps in device_timeline.items():
        if len(timestamps) < 2:
            continue
            
        timestamps.sort()
        
        # Check for gaps
        for i in range(1, len(timestamps)):
            prev_time = timestamps[i-1]
            curr_time = timestamps[i]
            diff = curr_time - prev_time
            
            if diff > gap_threshold:
                problematic_devices.append(dev_id)
                # Once a device is flagged, we don't need to check its other gaps
                break

    # 3. Report Results
    print(f"\n--- Analysis Complete ---")
    print(f"Lines Processed: {line_count}")
    print(f"Unique Devices Found: {len(device_timeline)}")
    print(f"Devices with Gaps > {gap_threshold}s: {len(problematic_devices)}")
    print("-" * 30)
    
    if problematic_devices:
        print("Devices with missing data gaps:")
        for dev in problematic_devices:
            print(f" -> {dev}")
    else:
        print("No gaps detected. All devices have consistent reporting.")

if __name__ == "__main__":
    # You can change 'data.json' to your actual filename
    # Or pass it as a command line argument: python script.py my_data.json
    
    if len(sys.argv) > 1:
        input_file = sys.argv[1]
    else:
        # Default filename if no argument provided
        input_file = '' 
        
    scan_file_for_gaps(input_file)
